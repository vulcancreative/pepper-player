var pepper =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/assert.js":
/*!***********************!*\
  !*** ./src/assert.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction assert() {\n  var comp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  var message = arguments[1];\n\n  if (!comp) {\n    var suffix = \"\";\n    if (message) {\n      suffix = \"; \" + message;\n    }\n\n    throw \"Assertion error\" + suffix;\n  }\n};\n\nexports.assert = assert;\n\n//# sourceURL=webpack://pepper/./src/assert.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar kProtocol = {\n  hls: 'HLS',\n  dash: 'DASH'\n};\n\nvar kStreamType = {\n  audio: 'audio',\n  video: 'video',\n  muxed: 'muxed'\n};\n\nvar kSegmentType = {\n  init: 'initialization',\n  segment: 'segment'\n};\n\nvar kTransitions = {\n  countdown: 'countdown',\n  immedaite: 'immediate'\n};\n\nvar kBackingType = {\n  splitX: 'splitX',\n  splitY: 'splitY',\n  uniform: 'uniform'\n};\n\nexports.kProtocol = kProtocol;\nexports.kStreamType = kStreamType;\nexports.kSegmentType = kSegmentType;\nexports.kTransitions = kTransitions;\nexports.kBackingType = kBackingType;\n\n//# sourceURL=webpack://pepper/./src/constants.js?");

/***/ }),

/***/ "./src/convert.js":
/*!************************!*\
  !*** ./src/convert.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toDuration = exports.toInt = undefined;\n\nvar _assert = __webpack_require__(/*! ./assert */ \"./src/assert.js\");\n\n// parses a string to an int, only if possible\nfunction toInt(i) {\n  var remainder = i % 1;\n  var forcedInt = parseInt(i);\n\n  if (remainder === 0 && !isNaN(forcedInt)) {\n    return forcedInt;\n  } else if (isNaN(remainder)) {\n    return null;\n  } else if (i && typeof i !== 'undefined' && i != '') {\n    return forcedInt;\n  }\n\n  return null;\n}\n\n// parses an MPD-formatted duration\nfunction toDuration(d) {\n  (0, _assert.assert)(d !== null && typeof d !== 'undefined');\n  (0, _assert.assert)(d.length > 0);\n\n  var result = 0,\n      duration = d,\n      hours = void 0,\n      minutes = void 0,\n      seconds = void 0;\n\n  if (duration.length >= 2) {\n    var sub = duration.substring(0, 2).toUpperCase();\n\n    if (sub === \"PT\") {\n      duration = duration.substring(2, duration.length);\n    } else if ((sub[0] === 'P' || sub[0] === 'T') && !isNaN(parseInt(sub[1]))) {\n      duration = duration.substring(1, duration.length);\n    }\n  } else {\n    return result;\n  }\n\n  if (duration.includes('H')) {\n    duration = duration.toUpperCase().split('H');\n    hours = duration.length > 1 ? parseInt(duration[0]) : 0;\n    duration = duration[1] || duration + '';\n  }\n\n  if (duration.includes('M')) {\n    duration = duration.toUpperCase().split('M');\n    minutes = duration.length > 1 ? parseInt(duration[0]) : 0;\n    duration = duration[1] || duration + '';\n  }\n\n  if (duration.includes('S')) {\n    duration = duration.toUpperCase().split('S');\n    seconds = duration.length > 1 ? parseFloat(duration[0]) : 0;\n  }\n\n  if (hours !== null && typeof hours !== 'undefined' && !isNaN(hours)) {\n    result += 3600 * hours;\n  }\n\n  if (minutes !== null && typeof minutes !== 'undefined' && !isNaN(minutes)) {\n    result += 60 * minutes;\n  }\n\n  if (seconds !== null && typeof seconds !== 'undefined' && !isNaN(seconds)) {\n    result += seconds;\n  }\n\n  return result * 1000;\n}\n\nexports.toInt = toInt;\nexports.toDuration = toDuration;\n\n//# sourceURL=webpack://pepper/./src/convert.js?");

/***/ }),

/***/ "./src/helpers.js":
/*!************************!*\
  !*** ./src/helpers.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isInt = exports.nodeOfType = exports.randInt = exports.randStr = exports.mergeDicts = exports.sizeDict = undefined;\n\nvar _assert = __webpack_require__(/*! ./assert */ \"./src/assert.js\");\n\n// counts items in a dictionary and returns the size\nfunction sizeDict(d) {\n  var result = 0;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.keys(d)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var i = _step.value;\n\n      if (d.hasOwnProperty(i)) {\n        result++;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return result;\n}\n\n// merges two dictionaries, with the first one taking priority\nfunction mergeDicts(a, b) {\n  (0, _assert.assert)(a);\n  (0, _assert.assert)(b);\n\n  var result = {};\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = Object.keys(b)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var k = _step2.value;\n\n      result[k] = a[k] !== null && typeof a[k] !== 'undefined' ? a[k] : b[k];\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return result;\n}\n\n// generates a random alpha-numeric string of \"len\" length\nfunction randStr() {\n  var len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n\n  (0, _assert.assert)(len);\n  (0, _assert.assert)(len > 0);\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \"abcdefghijklmnopqrstuvwxyz0123456789\";\n\n  var result = [];\n\n  for (var i = 0; i < len; i++) {\n    result.push(chars.charAt(Math.floor(Math.random() * chars.length)));\n  }\n\n  return result.join(\"\");\n}\n\n// generates a random integer between a provided range\nfunction randInt(min, max) {\n  return parseInt(Math.floor(Math.random() * (max - min + 1) + min));\n}\n\n// ensures n is of lower-case string type t: e.g. <video> === \"video\"\nfunction nodeOfType(n, t) {\n  if (!n) {\n    return false;\n  }\n  if (!n.nodeName) {\n    return false;\n  }\n\n  return n.nodeName.toLowerCase() == t;\n}\n\n// checks whether a variable is an integer or not\nfunction isInt(value) {\n  if (isNaN(value)) {\n    return false;\n  }\n  var x = parseFloat(value);\n  return (x | 0) === x;\n}\n\nexports.sizeDict = sizeDict;\nexports.mergeDicts = mergeDicts;\nexports.randStr = randStr;\nexports.randInt = randInt;\nexports.nodeOfType = nodeOfType;\nexports.isInt = isInt;\n\n//# sourceURL=webpack://pepper/./src/helpers.js?");

/***/ }),

/***/ "./src/hooker.js":
/*!***********************!*\
  !*** ./src/hooker.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n// allows for custom hooks\nvar Hooker = function () {\n  function Hooker() {\n    _classCallCheck(this, Hooker);\n\n    this.callbacks_ = {};\n  }\n\n  _createClass(Hooker, [{\n    key: \"on\",\n    value: function on(cb) {\n      for (var _len = arguments.length, events = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        events[_key - 1] = arguments[_key];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        var event = events[i];\n\n        // TODO: finish\n        if (!this.callbacks_[event]) {\n          this.callbacks_[event] == [];\n        }\n\n        var found = false;\n        var list = this.callbacks_[event];\n\n        for (var _i = 0; _i < list.length; _i++) {\n          var item = list[_i];\n          if (item === cb) {\n            found = true;break;\n          }\n        }\n\n        if (!found) {\n          this.callbacks_[event].push(cb);\n        }\n      }\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, data) {\n      this.dispatch(event, data);\n      return this;\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(event, data) {\n      chain = this.callbacks_[event];\n\n      if (chain) {\n        for (var i = 0; i < chain.length; i++) {\n          var callback = chain[i];\n          callback(data);\n        }\n      }\n    }\n  }]);\n\n  return Hooker;\n}();\n\nexports.Hooker = Hooker;\n\n//# sourceURL=webpack://pepper/./src/hooker.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _player = __webpack_require__(/*! ./player */ \"./src/player.js\");\n\nObject.keys(_player).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _player[key];\n    }\n  });\n});\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nObject.keys(_constants).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _constants[key];\n    }\n  });\n});\n\n//# sourceURL=webpack://pepper/./src/index.js?");

/***/ }),

/***/ "./src/measure.js":
/*!************************!*\
  !*** ./src/measure.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction kbps(bytes, delta) {\n  var bitsLoaded = bytes * 8;\n  var speedBps = (bitsLoaded / delta).toFixed(2);\n  var speedKbps = (speedBps / 1024).toFixed(2);\n\n  return speedKbps;\n}\n\n// take a speed (kbps), size (bytes), and a time (ms)\n// returns percentage (float) of time that it would take to process size\nfunction speedFactor(speed, size, delta) {\n  var bits = size * 8;\n  var speedBps = speed * 1024;\n  var seconds = delta / 1000;\n  var ttl = bits / speedBps;\n\n  console.log(\"ttl: \" + ttl + \", seconds: \" + seconds);\n  var contrast = (parseFloat(ttl) / parseFloat(seconds)).toFixed(2);\n  return contrast;\n}\n\nexports.kbps = kbps;\nexports.speedFactor = speedFactor;\n\n//# sourceURL=webpack://pepper/./src/measure.js?");

/***/ }),

/***/ "./src/mpd.js":
/*!********************!*\
  !*** ./src/mpd.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MPD = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nvar _assert = __webpack_require__(/*! ./assert */ \"./src/assert.js\");\n\nvar _hooker = __webpack_require__(/*! ./hooker */ \"./src/hooker.js\");\n\nvar _helpers = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n\nvar _convert = __webpack_require__(/*! ./convert */ \"./src/convert.js\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Rep = function () {\n  function Rep(adp, rep, override) {\n    _classCallCheck(this, Rep);\n\n    var id = void 0,\n        codecs = void 0,\n        width = void 0,\n        height = void 0,\n        bandwidth = void 0,\n        baseURL = void 0,\n        initialization = void 0,\n        mediaTemplate = void 0,\n        segmentTemplate = void 0,\n        startNumber = void 0,\n        timescale = void 0,\n        mimeType = void 0,\n        segmentDuration = void 0;\n\n    // source id from rep attribute\n    id = rep.getAttribute('id');\n\n    // mimeType can be on either the adp or the rep\n    mimeType = adp.getAttribute('mimeType');\n    if (!mimeType || typeof mimeType === 'undefined') {\n      mimeType = rep.getAttribute('mimeType');\n    }\n\n    // source codecs from rep attribute\n    codecs = rep.getAttribute('codecs');\n\n    // find dimensions and parse to integer\n    var widthAttr = rep.getAttribute('width');\n    var heightAttr = rep.getAttribute('height');\n\n    width = (0, _convert.toInt)(widthAttr);\n    height = (0, _convert.toInt)(heightAttr);\n\n    // find bandwidth and parse to integer\n    var bandwidthAttr = rep.getAttribute('bandwidth');\n    bandwidth = (0, _convert.toInt)(bandwidthAttr);\n\n    // get default baseURL, if available and no override\n    if (typeof override === 'string' || override instanceof String) {\n      baseURL = override || \"\";\n    }\n\n    if (baseURL.length < 1) {\n      var urlContainer = adp.querySelectorAll('BaseURL')[0];\n      if (urlContainer && urlContainer.textContent) {\n        baseURL = urlContainer.textContent.trim();\n      }\n    }\n\n    // find segment template\n    segmentTemplate = adp.querySelectorAll('SegmentTemplate')[0];\n    if (!segmentTemplate || typeof segmentTemplate === 'undefined') {\n      segmentTemplate = rep.querySelectorAll('SegmentTemplate')[0];\n    }\n\n    if (segmentTemplate) {\n      mediaTemplate = segmentTemplate.getAttribute('media');\n\n      initialization = segmentTemplate.getAttribute('initialization');\n      initialization = initialization.replace(\"$RepresentationID$\", id);\n\n      var startNumAttr = segmentTemplate.getAttribute('startNumber');\n      startNumber = (0, _convert.toInt)(startNumAttr);\n\n      var timescaleAttr = segmentTemplate.getAttribute('timescale');\n      timescale = (0, _convert.toInt)(timescaleAttr);\n\n      var segDurationAttr = segmentTemplate.getAttribute('duration');\n      segmentDuration = (0, _convert.toInt)(segDurationAttr);\n    }\n\n    this.id = id;\n    this.mimeType = mimeType;\n    this.codecs = codecs;\n    this.width = width;\n    this.height = height;\n    this.bandwidth = bandwidth;\n    this.baseURL = baseURL;\n    this.mediaTemplate = mediaTemplate;\n    this.initialization = initialization;\n    this.startNumber = startNumber;\n    this.timescale = timescale;\n    this.segmentDuration = segmentDuration;\n  }\n\n  _createClass(Rep, [{\n    key: 'weight',\n    value: function weight() {\n      var weight = 0;\n\n      if (this.width && this.height) {\n        weight += this.width + this.height;\n      } else if (this.bandwidth) {\n        weight += this.bandwidth;\n      }\n\n      return weight;\n    }\n  }]);\n\n  return Rep;\n}();\n\nvar Adp = function () {\n  function Adp(adp, i, override) {\n    _classCallCheck(this, Adp);\n\n    var maxWidth = void 0,\n        maxHeight = void 0;\n\n    var maxWidthAttr = adp.getAttribute('maxWidth');\n    var maxHeightAttr = adp.getAttribute('maxHeight');\n\n    this.adp = adp;\n    this.maxWidth = (0, _convert.toInt)(maxWidthAttr);\n    this.maxHeight = (0, _convert.toInt)(maxHeightAttr);\n    this.reps = this.reps_(adp, override);\n  }\n\n  _createClass(Adp, [{\n    key: 'reps_',\n    value: function reps_(adp, override) {\n      var representations = adp.querySelectorAll(\"Representation\");\n\n      if (representations && representations.length > 0) {\n        var reps = [];\n\n        for (var _i = 0; _i != representations.length; _i++) {\n          var rep = representations[_i];\n\n          reps.push(new Rep(adp, rep, override));\n        }\n\n        return reps;\n      } else {\n        throw 'No representations present in adaptation[' + i + ']';\n      }\n    }\n\n    // TODO: consolidate shared code with the following 3 methods\n\n  }, {\n    key: 'bestRep',\n    value: function bestRep() {\n      var weight = 0;\n      var heaviestRep = 0;\n\n      if (this.reps.length < 1) {\n        return null;\n      } else if (this.reps.length === 1) {\n        return 0;\n      }\n\n      for (var _i2 = 0; _i2 < this.reps.length; _i2++) {\n        var rep = this.reps[_i2];\n\n        var currentWeight = rep.weight();\n\n        if (currentWeight > weight) {\n          weight = currentWeight;\n          heaviestRep = _i2;\n        }\n      }\n\n      return heaviestRep;\n    }\n\n    // TODO: consolidate shared code with the following method\n\n  }, {\n    key: 'strongerRep',\n    value: function strongerRep(repID) {\n      (0, _assert.assert)(repID !== null && typeof repID !== 'undefined', 'rep \"' + repID + '\" invalid in strongerRep before targeting');\n\n      var rep = void 0;\n\n      for (var _i3 = 0; _i3 != this.reps.length; _i3++) {\n        if (this.reps[_i3].id === repID) {\n          rep = this.reps[_i3];break;\n        }\n      }\n\n      (0, _assert.assert)(rep !== null && typeof rep !== 'undefined', 'rep \"' + rep.id + '\" invalid in strongerRep after targeting');\n\n      var currentRep = void 0;\n      var currentWeight = rep.weight();\n\n      for (var _i4 = 0; _i4 != this.reps.length; _i4++) {\n        if (this.reps[_i4].id === repID) {\n          currentRep = this.reps[_i4];\n          continue;\n        }\n\n        var weight = this.reps[_i4].weight();\n        if (weight > currentWeight) {\n          return this.reps[_i4];\n        }\n      }\n\n      return currentRep;\n    }\n  }, {\n    key: 'weakerRep',\n    value: function weakerRep(repID) {\n      (0, _assert.assert)(repID !== null && typeof repID !== 'undefined', 'rep \"' + repID + '\" invalid in weakerRep before targeting');\n\n      var rep = void 0;\n\n      for (var _i5 = 0; _i5 != this.reps.length; _i5++) {\n        if (this.reps[_i5].id === repID) {\n          rep = this.reps[_i5];break;\n        }\n      }\n\n      (0, _assert.assert)(rep !== null && typeof rep !== 'undefined', 'rep \"' + rep.id + '\" invalid in weakerRep after targeting');\n\n      var currentRep = void 0;\n      var currentWeight = rep.weight();\n\n      for (var _i6 = 0; _i6 != this.reps.length; _i6++) {\n        if (this.reps[_i6].id === repID) {\n          currentRep = this.reps[_i6];\n          continue;\n        }\n\n        var weight = this.reps[_i6].weight();\n        if (weight < currentWeight) {\n          return this.reps[_i6];\n        }\n      }\n\n      return currentRep;\n    }\n  }, {\n    key: 'worstRep',\n    value: function worstRep() {\n      var weight = 0;\n      var lightestRep = 0;\n\n      if (this.reps.length < 1) {\n        return null;\n      } else if (this.reps.length === 1) {\n        return 0;\n      }\n\n      for (var _i7 = 0; _i7 < this.reps.length; _i7++) {\n        var rep = this.reps[_i7];\n\n        var currentWeight = rep.weight();\n\n        if (weight < 1 || currentWeight < weight) {\n          weight = currentWeight;\n          lightestRep = _i7;\n        }\n      }\n\n      return lightestRep;\n    }\n  }]);\n\n  return Adp;\n}();\n\nvar MPD = function (_Hooker) {\n  _inherits(MPD, _Hooker);\n\n  function MPD() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MPD);\n\n    var _this = _possibleConstructorReturn(this, (MPD.__proto__ || Object.getPrototypeOf(MPD)).call(this));\n\n    var kDefaultConfig = {\n      url: \"\",\n      base: \"\"\n    };\n\n    _this.config = (0, _helpers.mergeDicts)(config, kDefaultConfig);\n    return _this;\n  }\n\n  _createClass(MPD, [{\n    key: 'setup',\n    value: function setup() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this2.fetch_(_this2.config.url).then(function (result) {\n          _this2.parse_(result);\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: 'fetch_',\n    value: function fetch_() {\n      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n          if (xhr.status >= 200 && xhr.status < 400) {\n            if (!xhr.response || xhr.response.trim().length < 1) {\n              reject(\"Attempt to fetch MPD failed\");\n            }\n\n            console.log(xhr.response);\n            resolve(xhr.response);\n          } else {\n            reject(\"Attempt to fetch MPD failed\");\n          }\n        };\n\n        xhr.open('GET', url);\n        xhr.send();\n      });\n    }\n  }, {\n    key: 'parse_',\n    value: function parse_() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n      (0, _assert.assert)(input && typeof input !== 'undefined');\n      (0, _assert.assert)(input.length && input.length > 0);\n\n      var baseOverride = this.config.base;\n      this.mpd = this.xml_(input);\n\n      (0, _assert.assert)(this.mpd !== null && typeof this.mpd !== 'undefined');\n      (0, _assert.assert)(this.mpd.children.length > 0);\n\n      // dependency for adp and rep sourcing\n      this.baseURL = this.baseURL_(this.mpd, baseOverride);\n\n      this.adps = this.adps_(this.mpd, this.baseURL);\n      this.duration = this.duration_(this.mpd);\n      this.muxed = this.muxed_(this.mpd);\n      this.type = this.type_(this.mpd);\n      this.updatePeriod = this.updatePeriod_(this.mpd);\n\n      (0, _assert.assert)(this.adps !== null && typeof this.adps !== 'undefined');\n      (0, _assert.assert)(typeof this.baseURL !== 'undefined');\n      (0, _assert.assert)(this.duration !== null && typeof this.duration !== 'undefined');\n      (0, _assert.assert)(this.muxed !== null && typeof this.muxed !== 'undefined');\n      (0, _assert.assert)(this.type !== null && typeof this.type !== 'undefined');\n\n      (0, _assert.assert)(typeof this.updatePeriod !== 'undefined');\n    }\n\n    // source adaptations and populate with critical data and metadata\n    // mpd === parsed MPD XML\n\n  }, {\n    key: 'adps_',\n    value: function adps_(mpd, override) {\n      var period = mpd.querySelectorAll(\"Period\")[0];\n      var adaptations = period.querySelectorAll(\"AdaptationSet\");\n\n      if (adaptations && adaptations.length > 0) {\n        var adps = [];\n\n        for (var _i8 = 0; _i8 != adaptations.length; _i8++) {\n          var adaptation = adaptations[_i8];\n          adps.push(new Adp(adaptation, _i8, override));\n        }\n\n        return adps;\n      } else {\n        throw \"No AdaptationSet present in manifest.\";\n      }\n    }\n\n    // gets MPD-level base URL\n    // mpd === parsed MPD XML\n\n  }, {\n    key: 'baseURL_',\n    value: function baseURL_(mpd, override) {\n      if (typeof override === 'string' || override instanceof String) {\n        if (override.length > 0) {\n          return override;\n        }\n      }\n\n      var url = mpd.querySelectorAll(\"MPD BaseURL\")[0];\n      url = url && url.textContent ? url.textContent.trim() : '/';\n      url += url.charAt(url.length - 1) !== '/' ? '/' : '';\n\n      return url;\n    }\n\n    // acquires overall duration, if possible (VoD)\n    // mpd === parsed MPD XML\n\n  }, {\n    key: 'duration_',\n    value: function duration_(mpd) {\n      var root = mpd.querySelectorAll(\"MPD\")[0];\n\n      if (root !== null && typeof root !== 'undefined') {\n        var durationAttr = root.getAttribute(\"mediaPresentationDuration\");\n\n        if (durationAttr !== null && typeof durationAttr !== 'undefined') {\n          if (durationAttr.length < 1) {\n            return null;\n          }\n        }\n\n        return (0, _convert.toDuration)(durationAttr);\n      } else {\n        throw \"MPD is invalid; unable to source overall duration.\";\n      }\n    }\n\n    // samples a representations codecs\n    // if both avc1 and mp4a codecs detected in same rep, true is returned\n    // mpd === parsed MPD XML\n\n  }, {\n    key: 'muxed_',\n    value: function muxed_(mpd) {\n      var rep = mpd.querySelectorAll(\"Representation\")[0];\n\n      if (rep && typeof rep !== 'undefined') {\n        var codecs = rep.getAttribute('codecs');\n        if (codecs.includes(',')) {\n          var vid = false,\n              aud = false,\n              vID = \"avc\",\n              aID = \"mp4\";\n\n          var s = codecs.split(\",\");\n\n          if (s[0].substring(0, 3) == vID || s[1].substring(0, 3) == vID) {\n            vid = true;\n          }\n\n          if (s[0].substring(0, 3) == aID || s[1].substring(0, 3) == aID) {\n            aud = true;\n          }\n\n          if (vid && aud) {\n            return true;\n          }\n        }\n\n        return false;\n      } else {\n        throw \"Unable to find Representation within MPD.\";\n      }\n    }\n\n    // determined if we have a live (\"dynamic\") or vod (\"static\") stream\n\n  }, {\n    key: 'type_',\n    value: function type_(mpd) {\n      var root = mpd.querySelectorAll(\"MPD\")[0];\n\n      if (root && typeof root !== 'undefined') {\n        var type = root.getAttribute('type');\n\n        if (!type || type.trim() === '') {\n          return null;\n        }\n        return type.trim();\n      } else {\n        throw \"MPD is invalid; unable to source type.\";\n      }\n    }\n\n    // acquires MPD update period, if possible (live)\n    //) mpd === parsed MPD XML\n\n  }, {\n    key: 'updatePeriod_',\n    value: function updatePeriod_(mpd) {\n      var root = mpd.querySelectorAll(\"MPD\")[0];\n      if (root !== null && typeof root !== 'undefined') {\n        var periodAttr = root.getAttribute('minimumUpdatePeriod');\n\n        if (periodAttr === null || typeof periodAttr === 'undefined') {\n          return null;\n        }\n\n        return (0, _convert.toDuration)(periodAttr);\n      } else {\n        throw \"MPD is invalid; unable to source minimumUpdatePeriod.\";\n      }\n    }\n\n    // converts to DOM-accessible XML, if not already in it\n    // manifest === manifest string or implicitly parsed MPD XML\n\n  }, {\n    key: 'xml_',\n    value: function xml_(mpd) {\n      var hasDOM = mpd.querySelectorAll ? true : false;\n\n      if (!hasDOM || !mpd.querySelectorAll(\"Period\")[0]) {\n        var parser = new DOMParser();\n        var xml = parser.parseFromString(mpd, 'text/xml', 0);\n        return xml;\n      } else if (hasDOM) {\n        return mpd;\n      } else {\n        throw \"MPD undefined or unable to be parsed.\";\n      }\n    }\n  }]);\n\n  return MPD;\n}(_hooker.Hooker);\n\nexports.MPD = MPD;\n\n//# sourceURL=webpack://pepper/./src/mpd.js?");

/***/ }),

/***/ "./src/player.js":
/*!***********************!*\
  !*** ./src/player.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Player = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nvar _state = __webpack_require__(/*! ./state */ \"./src/state.js\");\n\nvar _assert = __webpack_require__(/*! ./assert */ \"./src/assert.js\");\n\nvar _hooker = __webpack_require__(/*! ./hooker */ \"./src/hooker.js\");\n\nvar _helpers = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar Player = function (_Hooker) {\n  _inherits(Player, _Hooker);\n\n  function Player() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Player);\n\n    var _this = _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this));\n\n    var kDefaultConfig = {\n      playlist: [\n        // {\n        // dash: {\n        // url:    null,\n        // base:   null,\n        // },\n        // hls: {\n        // url:    null,\n        // gen:    null,\n        // },\n        // },\n      ],\n\n      auto: true,\n      adapt: true,\n      base: 1000,\n      lead: 5000,\n      loop: false,\n      query: \"video.pepper\",\n      start: 0,\n      track: 0\n    };\n\n    _this.config = (0, _helpers.mergeDicts)(config, kDefaultConfig);\n    _this.setup_();\n    return _this;\n  }\n\n  _createClass(Player, [{\n    key: 'setup_',\n    value: function setup_() {\n      var _this2 = this;\n\n      if (!this.config.query.length || this.config.query.length < 1) {\n        throw \"Invalid insertion query.\";\n      }\n\n      if (this.config.base < 100) {\n        this.config.base = 100;\n      }\n      if (this.config.lead < 1000) {\n        this.config.lead = 1000;\n      }\n\n      this.state = new _state.State(this.config);\n      this.state.setup().then(function () {\n        return console.log(\"State ready\");\n      }).then(function () {\n        return _this2.state.fillBuffers();\n      }).then(function (speed) {\n        return _this2.state.adjustQuality(speed);\n      }).then(function () {\n        if (_this2.config.auto) {\n          _this2.play();\n        }\n      });\n    }\n  }, {\n    key: 'bufferTime',\n    value: function bufferTime() {\n      return this.state.bufferTime;\n    }\n  }, {\n    key: 'currentTime',\n    value: function currentTime() {\n      return this.state.video.currentTime * 1000;\n    }\n  }, {\n    key: 'didEnd',\n    value: function didEnd() {\n      return this.currentTime() >= this.duration();\n    }\n  }, {\n    key: 'duration',\n    value: function duration() {\n      return this.state.mpd.duration;\n    }\n  }, {\n    key: 'isPaused',\n    value: function isPaused() {\n      // TODO\n    }\n  }, {\n    key: 'makeActive',\n    value: function makeActive() {\n      // TODO\n    }\n  }, {\n    key: 'next',\n    value: function next() {\n      // TODO\n    }\n  }, {\n    key: 'pause',\n    value: function pause() {\n      return this.state.video.pause();\n    }\n  }, {\n    key: 'play',\n    value: function play() {\n      var _this3 = this;\n\n      return this.state.video.play().then(function () {\n        _this3.state.video.ontimeupdate = function () {\n          var currentTime = _this3.currentTime();\n          var bufferTime = _this3.bufferTime();\n          var leadTime = _this3.config.lead;\n\n          if (currentTime >= bufferTime - leadTime / 2) {\n            _this3.state.fillBuffers().then(function (speed) {\n              _this3.state.adjustQuality(speed);\n            });\n          }\n\n          if (_this3.currentTime() >= _this3.duration()) {\n            _this3.state.video.currentTime = 0;\n            if (!_this3.config.loop) {\n              _this3.state.video.pause();\n            }\n          }\n        };\n      });\n    }\n  }, {\n    key: 'previous',\n    value: function previous() {\n      // TODO\n    }\n  }, {\n    key: 'seek',\n    value: function seek() {\n      // TODO\n    }\n  }]);\n\n  return Player;\n}(_hooker.Hooker);\n\nexports.Player = Player;\n\n//# sourceURL=webpack://pepper/./src/player.js?");

/***/ }),

/***/ "./src/state.js":
/*!**********************!*\
  !*** ./src/state.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.State = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nvar _mpd = __webpack_require__(/*! ./mpd */ \"./src/mpd.js\");\n\nvar _assert = __webpack_require__(/*! ./assert */ \"./src/assert.js\");\n\nvar _hooker = __webpack_require__(/*! ./hooker */ \"./src/hooker.js\");\n\nvar _stream = __webpack_require__(/*! ./stream */ \"./src/stream.js\");\n\nvar _helpers = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n\nvar _measure = __webpack_require__(/*! ./measure */ \"./src/measure.js\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof2(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof2(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\n/*\n// TODO: move within class structure\n// merge passed config with default config; returning assembled config\nfunction configure(config, kDefaultConfig) {\n  assert(config);\n  assert(kDefaultConfig);\n\n  mergedConfig = mergeDicts(config, kDefaultConfig);\n  mergedConfig.playlist = validatePlaylist(mergedConfig.playlist);\n\n  return mergedConfig;\n}\n*/\n\nvar State = function (_Hooker) {\n  _inherits(State, _Hooker);\n\n  function State() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, State);\n\n    var _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));\n\n    var kDefaultConfig = {\n      playlist: [],\n      base: 0,\n      lead: 0,\n      start: 0,\n      track: 0,\n      query: \"\"\n    };\n\n    _this.config = (0, _helpers.mergeDicts)(config, kDefaultConfig);\n    return _this;\n  }\n\n  _createClass(State, [{\n    key: 'setup',\n    value: function setup() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var track = _this2.config.track;\n        var url = _this2.config.playlist[track].dash.url;\n        var base = _this2.config.playlist[track].dash.base;\n\n        var root = document.querySelectorAll(_this2.config.query)[0];\n\n        if (root === null || typeof root === 'undefined') {\n          reject(\"Unable to find root element for insertion query.\");\n        }\n\n        _this2.video = root;\n        _this2.loading = false;\n        _this2.started = false;\n        _this2.bufferTime = _this2.config.start;\n\n        _this2.mpd = new _mpd.MPD({ url: url, base: base });\n        _this2.mpd.setup().then(function () {\n          return console.log(\"MPD parsed\");\n        }).then(function () {\n          return _this2.mediaSource_();\n        }).then(function (mediaSource) {\n          _this2.mediaSource = mediaSource;\n        }).then(function () {\n          return _this2.buildStreams_(_this2.mpd, _this2.mediaSource);\n        }).then(function (streams) {\n          _this2.streams = streams;\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: 'buildStreams_',\n    value: function buildStreams_(mpd, mediaSource) {\n      return new Promise(function (resolve, reject) {\n        var counter = 0;\n        var streams = [];\n\n        var _loop = function _loop(i) {\n          var adp = mpd.adps[i];\n          var rep = adp.reps[adp.bestRep()];\n          (0, _assert.assert)(rep !== null && typeof rep !== 'undefined');\n\n          var stream = new _stream.Stream({\n            mediaSource: mediaSource,\n            mpd: mpd,\n            adp: adp,\n            rep: rep,\n            sources: mpd.adps[i].reps\n          });\n\n          stream.setup().then(function () {\n            streams.push(stream);\n            counter++;\n\n            if (counter === mpd.adps.length) {\n              resolve(streams);\n            }\n          });\n        };\n\n        for (var i = 0; i < mpd.adps.length; i++) {\n          _loop(i);\n        }\n      });\n    }\n  }, {\n    key: 'mediaSource_',\n    value: function mediaSource_() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var mediaSource = new MediaSource();\n\n        (0, _assert.assert)(mediaSource !== null);\n        (0, _assert.assert)(typeof mediaSource !== 'undefined');\n\n        mediaSource.addEventListener('sourceopen', function () {\n          if (mediaSource.readyState === 'open') {\n            console.log(\"Media source successfully opened\");\n            resolve(mediaSource);\n          } else {\n            reject(\"Unable to open media source!\");\n          }\n        });\n\n        var src = _this3.url_(mediaSource);\n\n        (0, _assert.assert)(src !== null && typeof src !== 'undefined');\n        (0, _assert.assert)(src.length > 0);\n\n        _this3.video.src = src;\n        console.log(_this3.video);\n      });\n    }\n  }, {\n    key: 'url_',\n    value: function url_(ms) {\n      if (ms !== null && typeof ms !== 'undefined') {\n        return URL.createObjectURL(ms);\n      } else {\n        throw \"Media source is invalid.\";\n        return null;\n      }\n    }\n  }, {\n    key: 'adjustQuality',\n    value: function adjustQuality() {\n      var _this4 = this;\n\n      var factor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\n\n      // fail if actively buffering\n      if (this.loading) {\n        return Promise.resolve();\n      }\n\n      this.loading = true;\n\n      return new Promise(function (resolve, reject) {\n        var _loop2 = function _loop2(i) {\n          var stream = _this4.streams[i];\n          var adp = stream.adp;\n\n          var rep = void 0;\n\n          // lower quality if factor > 0.5; raise if < 0.25\n          if (factor >= 0.45) {\n            rep = adp.weakerRep(stream.rep.id);\n          } else if (factor <= 0.20) {\n            rep = adp.strongerRep(stream.rep.id);\n          } else {\n            _this4.loading = false;\n            resolve();\n\n            return {\n              v: void 0\n            };\n          }\n\n          (0, _assert.assert)(rep !== null && typeof rep !== 'undefined', \"rep invalid within adjustQuality\");\n\n          stream.switchToRep(rep.id).then(function () {\n            if (i === _this4.streams.length - 1) {\n              _this4.loading = false;\n              resolve();\n            }\n          });\n        };\n\n        for (var i = 0; i < _this4.streams.length; i++) {\n          var _ret2 = _loop2(i);\n\n          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n      });\n    }\n  }, {\n    key: 'codecs',\n    value: function codecs() {\n      return this.streams.map(function (stream) {\n        return stream.codecs();\n      });\n    }\n  }, {\n    key: 'fillBuffers',\n    value: function fillBuffers() {\n      var _this5 = this;\n\n      // fail if actively buffering\n      if (this.loading) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        // times measured against current and desired state\n        var start = _this5.bufferTime;\n        var lead = _this5.started ? _this5.config.lead : _this5.config.base;\n        var end = Math.min(_this5.mpd.duration, start + lead);\n\n        // used for measuring speed (in bytes)\n        var payloadSize = 0;\n        var payloadStart = new Date().getTime(),\n            payloadEnd = void 0;\n\n        // load-based lock\n        _this5.loading = true;\n\n        // double reducer for serialized Promise returns\n        // prevents the need for a (potentially) very large recursion stack\n        // derives some logic from: https://stackoverflow.com/a/24985483\n        return _this5.streams.reduce(function (promise, stream, streamIndex) {\n          return promise.then(function () {\n            var points = stream.makePoints(start, end);\n\n            /*\n            if (stream.inCache(points)) {\n              console.log(\"point found, returning...\");\n              return;\n            }\n            */\n\n            return points.reduce(function (promise, point, pointIndex) {\n              return promise.then(function () {\n                return stream.fillBuffer(point).then(function (dataSize) {\n                  var lastStream = streamIndex === _this5.streams.length - 1;\n                  var lastPoint = pointIndex === points.length - 1;\n\n                  // update payload weight\n                  payloadSize += dataSize;\n\n                  if (lastStream && lastPoint) {\n                    payloadEnd = new Date().getTime();\n\n                    var delta = (payloadEnd - payloadStart) / 1000;\n                    var speed = (0, _measure.kbps)(payloadSize, delta);\n                    var factor = (0, _measure.speedFactor)(speed, payloadSize, lead);\n\n                    _this5.bufferTime = end;\n\n                    _this5.started = true;\n                    _this5.loading = false;\n\n                    console.log('Buffers filled; download speed: ' + (speed + 'kbps, speedFactor: ' + factor));\n\n                    resolve(factor);\n                  }\n                });\n              });\n            }, Promise.resolve());\n          });\n        }, Promise.resolve());\n      });\n    }\n  }]);\n\n  return State;\n}(_hooker.Hooker);\n\nexports.State = State;\n\n//# sourceURL=webpack://pepper/./src/state.js?");

/***/ }),

/***/ "./src/stream.js":
/*!***********************!*\
  !*** ./src/stream.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Stream = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if (\"value\" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;\n  };\n}();\n\nvar _assert = __webpack_require__(/*! ./assert */ \"./src/assert.js\");\n\nvar _hooker = __webpack_require__(/*! ./hooker */ \"./src/hooker.js\");\n\nvar _strings = __webpack_require__(/*! ./strings */ \"./src/strings.js\");\n\nvar _helpers = __webpack_require__(/*! ./helpers */ \"./src/helpers.js\");\n\nvar _constants = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }return call && ((typeof call === \"undefined\" ? \"undefined\" : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : _typeof(superClass)));\n  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar Stream = function (_Hooker) {\n  _inherits(Stream, _Hooker);\n\n  function Stream() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Stream);\n\n    var _this = _possibleConstructorReturn(this, (Stream.__proto__ || Object.getPrototypeOf(Stream)).call(this));\n\n    var kDefaultConfig = {\n      mediaSource: null,\n      mpd: null,\n      adp: null,\n      rep: null,\n      sources: null\n    };\n\n    _this.config = (0, _helpers.mergeDicts)(config, kDefaultConfig);\n\n    _this.mediaSource = _this.config.mediaSource;\n\n    _this.adp = _this.config.adp;\n    _this.rep = _this.config.rep;\n    _this.sources = _this.config.sources;\n    (0, _assert.assert)(_this.rep !== null && typeof _this.rep !== 'undefined');\n\n    console.log(_this.rep);\n    return _this;\n  }\n\n  _createClass(Stream, [{\n    key: 'setup',\n    value: function setup() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this2.init_().then(function (cache) {\n          _this2.cache = cache;\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: 'init_',\n    value: function init_() {\n      var _this3 = this;\n\n      var cache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      return new Promise(function (resolve, reject) {\n        _this3.codecs = _this3.rep.mimeType + '; codecs=\"' + _this3.rep.codecs + '\"';\n\n        _this3.buffer = _this3.mediaSource.addSourceBuffer(_this3.codecs);\n        _this3.buffer.mode = 'sequence';\n\n        var _loop = function _loop(i) {\n          var source = _this3.sources[i];\n          var initName = source.initialization;\n          var baseURL = source.baseURL;\n          var initURL = baseURL ? '' + baseURL + initName : initName;\n\n          _this3.fetchSegment_(initURL).then(function (data) {\n            cache.push({\n              type: _constants.kSegmentType.init,\n              rep: source.id,\n              point: 0,\n              data: data,\n              size: data.byteLength\n            });\n\n            if (i === _this3.sources.length - 1) {\n              for (var j = 0; j != cache.length; j++) {\n                var segment = cache[j];\n                if (segment.point === 0 && segment.rep === _this3.rep.id) {\n                  _this3.appendBuffer(_this3.buffer, segment).then(function (buffer) {\n                    _this3.buffer = buffer;\n                    resolve(cache);\n                  });\n                }\n              }\n            }\n          });\n        };\n\n        for (var i = 0; i != _this3.sources.length; i++) {\n          _loop(i);\n        }\n      });\n    }\n  }, {\n    key: 'fetchSegment_',\n    value: function fetchSegment_() {\n      var _this4 = this;\n\n      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n\n      return new Promise(function (resolve, reject) {\n        var id = _this4.rep.id;\n        var xhr = new XMLHttpRequest();\n\n        xhr.onload = function () {\n          if (xhr.status >= 200 && xhr.status < 400) {\n            var data = xhr.response;\n\n            (0, _assert.assert)(data !== null && typeof data !== 'undefined');\n            (0, _assert.assert)(data.byteLength && data.byteLength > 0);\n\n            console.log('Fetched segment at \"' + url + '\" for rep \"' + id + '\"');\n            resolve(data);\n          } else {\n            reject('Unable to fetch segment at \"' + url + '\" for rep \"' + id + '\"');\n          }\n        };\n\n        xhr.open('GET', url);\n        xhr.responseType = 'arraybuffer';\n        xhr.send();\n      });\n    }\n  }, {\n    key: 'appendBuffer',\n    value: function appendBuffer(buffer, segment) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        var rep = _this5.rep;\n\n        if (buffer === null || typeof buffer === 'undefined') {\n          reject(\"Buffer invalid!\");\n        }\n\n        if (segment === null || typeof segment === 'undefined') {\n          reject(\"Segment invalid!\");\n        }\n\n        try {\n          buffer.appendBuffer(new Uint8Array(segment.data));\n          /*\n           * TODO: solidfy as trace-level debug text\n          console.log(\n            `Successfully appended ${segment.type} to ` +\n            `buffer for rep \"${rep.id}\"`\n          );\n          */\n        } catch (err) {\n          console.log(err);\n          reject('Failed to append ' + segment.type + ' to buffer for ' + ('rep \"' + rep.id + '\"'));\n        }\n\n        buffer.onupdateend = function () {\n          return resolve(buffer);\n        };\n      });\n    }\n  }, {\n    key: 'fillBuffer',\n    value: function fillBuffer(next) {\n      var _this6 = this;\n\n      return new Promise(function (resolve, reject) {\n        var rep = _this6.rep;\n\n        var nVarN = /\\$Number\\$/g,\n\n        //e.g \"...$Number$.m4s\"\n        nVarD = /(\\$Number%(\\d+)d\\$)/g,\n\n        //e.g \"...$Number%05d$.m4s\"\n        rVarN = /\\$RepresentationID\\$/g; //e.g \"stream$RepresentationID$...\"\n\n        /*\n         * TODO: solidfy as trace-level debug text\n        console.log(`Filling buffer for rep \"${rep.id}\"`);\n        console.log(`Current : ${current}, target : ${target}, ` +\n                    `segment length : ${this.segmentLength()}, ` +\n                    `steps : ${steps}`);\n        */\n\n        var mediaName = rep.mediaTemplate.replace(rVarN, '' + rep.id);\n\n        if (nVarD.test(mediaName)) {\n          var nVarDC = /(\\$Number%(\\d+)d\\$)/g;\n\n          var matches = nVarDC.exec(mediaName);\n          var amount = parseInt(matches[matches.length - 1]) + 1;\n          var segmentNumberExt = _strings.strings.pad(next, amount);\n\n          mediaName = mediaName.replace(matches[0], segmentNumberExt);\n        } else {\n          mediaName = mediaName.replace(nVarN, '' + next);\n        }\n\n        var baseURL = _this6.rep.baseURL;\n        var mediaURL = baseURL ? '' + baseURL + mediaName : mediaName;\n\n        _this6.fetchSegment_(mediaURL).then(function (data) {\n          _this6.cache.push({\n            type: _constants.kSegmentType.segment,\n            point: next,\n            data: data,\n            size: data.byteLength\n          });\n\n          var i = _this6.cache.length - 1;\n          _this6.appendBuffer(_this6.buffer, _this6.cache[i]).then(function (buffer) {\n            _this6.buffer = buffer;\n\n            // const newTime = parseInt(current + this.segmentLength());\n            resolve(data.byteLength);\n          });\n        });\n      });\n    }\n\n    // checks if a point (or array of points) has been cached\n\n  }, {\n    key: 'inCache',\n    value: function inCache() {\n      var _this7 = this;\n\n      var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      (0, _assert.assert)(points !== null && typeof points !== 'undefined');\n\n      var binSearchCache = function binSearchCache(point) {\n        var min = 0;\n        var max = _this7.cache.length - 1;\n        var index = void 0,\n            current = void 0;\n\n        while (min <= max) {\n          index = (min + max) / 2 | 0;\n          current = _this7.cache[index];\n\n          if (current.point < point) {\n            min = index + 1;\n          } else if (current.point > point) {\n            max = index - 1;\n          } else {\n            return index;\n          }\n        }\n\n        return -1;\n      };\n\n      if (points.constructor === Array) {\n        for (var i = 0; i != points.length; i++) {\n          var _point = points[i];\n          if (binSearchCache(_point) > 1) {\n            // console.log(`point(${point}) found`);\n            // console.log(this.cache);\n            return true;\n          }\n        }\n      } else if ((0, _helpers.isInt)(points)) {\n        if (binSearchCache(point) > 1) {\n          // console.log(`point(${point}) found`);\n          // console.log(this.cache);\n          return true;\n        }\n      } else {\n        throw 'Invalid argument value : \"' + points + '\"';\n      }\n\n      return false;\n    }\n  }, {\n    key: 'makePoints',\n    value: function makePoints(current, target) {\n      var rep = this.rep;\n      var delta = target - current;\n      var steps = parseInt(Math.ceil(parseFloat(delta) / parseFloat(this.segmentLength())));\n\n      var last = parseInt(Math.ceil(parseFloat(current) / parseFloat(this.segmentLength())));\n\n      var index = 0;\n      return new Array(steps).fill(last).map(function (v, i) {\n        return v + (i + 1);\n      });\n    }\n  }, {\n    key: 'segmentLength',\n    value: function segmentLength() {\n      var rep = this.rep;\n\n      if (rep !== null && typeof rep !== 'undefined') {\n        var timescale = parseFloat(rep.timescale);\n        var duration = parseFloat(rep.segmentDuration);\n        var ticks = Math.floor(duration / timescale);\n        var size = parseInt(ticks) * 1000;\n\n        return size;\n      } else {\n        throw 'Unable to determine segment length of rep \"' + rep.id + '\"';\n      }\n    }\n  }, {\n    key: 'switchToRep',\n    value: function switchToRep(repID) {\n      var _this8 = this;\n\n      return new Promise(function (resolve, reject) {\n        for (var i = 0; i != _this8.cache.length; i++) {\n          var segment = _this8.cache[i];\n\n          if (segment.point === 0 && segment.rep === repID) {\n            _this8.appendBuffer(_this8.buffer, segment).then(function (buffer) {\n              _this8.buffer = buffer;\n\n              for (var j = 0; j != _this8.sources.length; j++) {\n                var _source = _this8.sources[j];\n                if (_source.id === repID) {\n                  _this8.rep = _source;break;\n                }\n              }\n\n              resolve();\n            });\n          }\n        }\n      });\n    }\n  }]);\n\n  return Stream;\n}(_hooker.Hooker);\n\nexports.Stream = Stream;\n\n//# sourceURL=webpack://pepper/./src/stream.js?");

/***/ }),

/***/ "./src/strings.js":
/*!************************!*\
  !*** ./src/strings.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar strings = {};exports.strings = strings = function () {\n  // pads a string up to a certain number of characters with a passed\n  // character. If no passed character is received, 0 is used.\n  var pad = function pad(a, b, c, r) {\n    if ((a + '').length > b) {\n      return '???';\n    }\n\n    b = b ? b : 1;\n    return a < 10 && b == 2 ? '0' + a : b > 2 ? Array(b - (a + '').length).join(0) + a : '' + a;\n  };\n\n  // very simple URL detection\n  //\n  // the following strings should return true:\n  // \"http://test1.vulcanca.com/bbb.mpd\"\n  // \"https://aws.aslfkjsdkfjdsfb.vn/aslkdfjsklfjdlkjf.mp4\"\n  // \"/penis\"\n  //\n  // the following strings should return false:\n  // \"blahblahblah\"\n  // \"hwa\"\n  var isURL = function isURL(s) {\n    var p = /^(((http|https):\\/+)|\\/).*\\.?.*(\\/.*)?/;\n    return p.test(s);\n  };\n\n  // simple cents to USD conversion\n  //\n  // c is an unsigned integer representing cents\n  // z is an optional string to return if c == 0; otherwise returns \"0\"\n  var toUSD = function toUSD(c, z) {\n    c = parseInt(c), c = isNaN(c) ? 0 : c, c = c < 0 ? 0 : c, z = (z || '') + '';\n\n    // if c is 0 and z is valid, return z...\n    return c == 0 && z.length > 0 ? z :\n\n    // ...else, if c is 0, return \"0\"...\n    c == 0 ? '0' :\n\n    // ...else, convert\n    '$' + (parseFloat(c) / 100.0).toFixed(2);\n  };\n\n  return {\n    pad: pad,\n    isURL: isURL,\n    toUSD: toUSD\n  };\n}();\n\nexports.strings = strings;\n\n//# sourceURL=webpack://pepper/./src/strings.js?");

/***/ })

/******/ });